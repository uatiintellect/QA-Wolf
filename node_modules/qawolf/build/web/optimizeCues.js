"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeCues = exports.findBestCueGroup = exports.trimExcessCues = exports.sortCues = exports.combine = exports.buildCueSets = void 0;
const cues_1 = require("./cues");
const selectorEngine_1 = require("./selectorEngine");
/**
 * Build the cue sets.
 * There are multiple since each level of cues
 * can only have one type per level (css/text).
 */
exports.buildCueSets = (cues) => {
    const cueLevels = new Map();
    // Group cues into levels.
    cues.forEach((cue) => {
        const cueLevel = cueLevels.has(cue.level)
            ? cueLevels.get(cue.level)
            : { css: [], text: [] };
        if (cue.type === 'text') {
            cueLevel.text.push(cue);
        }
        else {
            cueLevel.css.push(cue);
        }
        cueLevels.set(cue.level, cueLevel);
    });
    let cueSets = [];
    const levels = [...cueLevels.keys()].sort((a, b) => b - a);
    levels.forEach((level) => {
        const cueLevel = cueLevels.get(level);
        const cueSetsWithLevel = [];
        // Append the level to each cue set
        // keeping css and text cues separate.
        cueSets.forEach((cueSet) => {
            if (cueLevel.css.length) {
                cueSetsWithLevel.push([...cueSet, ...cueLevel.css]);
            }
            if (cueLevel.text.length) {
                cueSetsWithLevel.push([...cueSet, ...cueLevel.text]);
            }
        });
        if (!cueSets.length) {
            // Create the first cue sets.
            if (cueLevel.css.length) {
                cueSetsWithLevel.push([...cueLevel.css]);
            }
            if (cueLevel.text.length) {
                cueSetsWithLevel.push([...cueLevel.text]);
            }
        }
        cueSets = cueSetsWithLevel;
    });
    return cueSets;
};
const doCombine = (items, remaining, combination, result) => {
    if (remaining === 0) {
        if (combination.length > 0) {
            result.push(combination);
        }
        return;
    }
    // For each item
    for (let i = 0; i < items.length; i++) {
        doCombine(
        // Combine the later items
        items.slice(i + 1), 
        // Recursively add items until we reach the correct size
        remaining - 1, 
        // Include the item in the selection
        combination.concat([items[i]]), result);
    }
    return;
};
/**
 * Build all combinations of items with the specified size.
 */
exports.combine = (items, size) => {
    const result = [];
    doCombine(items, size, [], result);
    return result;
};
exports.sortCues = (cues) => {
    return [...cues].sort((a, b) => {
        // Sort by level
        if (a.level < b.level)
            return 1;
        if (a.level > b.level)
            return -1;
        // Then by penalty
        if (a.penalty < b.penalty)
            return 1;
        if (a.penalty > b.penalty)
            return -1;
        // Then by the value length
        if (a.value.length < b.value.length)
            return 1;
        if (a.value.length > b.value.length)
            return -1;
        return 0;
    });
};
// Remove cues that are not necessary to target the element
// until we get to a size that we can try all combinations of
exports.trimExcessCues = (cuesToTrim, target, goalSize) => {
    let selectorParts = selectorEngine_1.buildSelectorParts(cuesToTrim);
    if (!selectorEngine_1.isMatch({ selectorParts, target })) {
        // Short-circuit if the cues do not match the target
        // This should never happen but we are being precautious
        console.debug('qawolf: selectors did not match', selectorParts, target);
        return null;
    }
    // Remove the cues furthest away from the target first
    let cues = exports.sortCues(cuesToTrim);
    for (let i = 0; i < cues.length && cues.length > goalSize; i++) {
        // Keep preferred attribute cues even if they are unnecessary
        if (cues[i].penalty === 0)
            continue;
        const cuesWithoutI = [...cues];
        cuesWithoutI.splice(i, 1);
        const selectorPartsWithoutI = selectorEngine_1.buildSelectorParts(cuesWithoutI);
        if (selectorEngine_1.isMatch({ selectorParts: selectorPartsWithoutI, target })) {
            cues = cuesWithoutI;
            selectorParts = selectorPartsWithoutI;
            i -= 1;
        }
    }
    return {
        cues,
        penalty: cues_1.getPenalty(cues),
        selectorParts,
        valueLength: cues_1.getValueLength(cues),
    };
};
// Go through every combination of cues from 1..max size
// Pick the cues that match the target with the lowest penalty
exports.findBestCueGroup = (seedGroup, target, maxSize) => {
    let bestGroup = seedGroup;
    // Keep the nearest attribute
    const cueToKeep = cues_1.findNearestPreferredAttributeCue(seedGroup.cues);
    for (let i = 1; i <= maxSize; i++) {
        const combinations = exports.combine(seedGroup.cues, i);
        combinations.forEach((cues) => {
            const penalty = cues_1.getPenalty(cues);
            // Skip these cues if they are not better
            if (penalty > bestGroup.penalty)
                return;
            const valueLength = cues_1.getValueLength(cues);
            if (penalty === bestGroup.penalty) {
                if (bestGroup.cues.length < cues.length)
                    return;
                if (bestGroup.cues.length === cues.length &&
                    valueLength >= bestGroup.valueLength)
                    return;
            }
            if (cueToKeep && !cues.includes(cueToKeep)) {
                cues.push(cueToKeep);
            }
            const selectorParts = selectorEngine_1.buildSelectorParts(cues);
            if (selectorEngine_1.isMatch({ selectorParts, target })) {
                bestGroup = {
                    cues,
                    penalty,
                    selectorParts,
                    valueLength,
                };
            }
        });
    }
    return bestGroup;
};
exports.optimizeCues = (cues, target) => {
    const cueSets = exports.buildCueSets(cues);
    // Only use the first 50 cue sets (there should never be this many, usually just ~2-3)
    const cueGroups = cueSets
        .slice(0, 50)
        .map((cueSet) => {
        // Trim down the cue group to 10 if possible
        // 10 cues, samples of 5 is ~700 combinations which took ~20ms on my machine
        const cueGroup = exports.trimExcessCues(cueSet, target, 10);
        // Skip if we cannot trim the group to <= 16 cues (this should rarely happen)
        // 16 cues, samples of 5 is ~7000 combinations which took ~100ms on my machine
        if (!cueGroup || cueGroup.cues.length > 16)
            return null;
        return exports.findBestCueGroup(cueGroup, target, 5);
    })
        // Ignore invalid groups
        .filter((a) => !!a)
        // Rank by the total penalty then by value length
        .sort((a, b) => {
        if (a.penalty < b.penalty)
            return -1;
        if (a.penalty > b.penalty)
            return 1;
        if (a.valueLength < b.valueLength)
            return -1;
        if (a.valueLength > b.valueLength)
            return 1;
        return 0;
    });
    return cueGroups.length ? cueGroups[0] : null;
};
//# sourceMappingURL=optimizeCues.js.map