"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSelector = exports.toSelector = exports.clearSelectorCache = void 0;
const cues_1 = require("./cues");
const optimizeCues_1 = require("./optimizeCues");
const serialize_1 = require("./serialize");
const selectorEngine_1 = require("./selectorEngine");
const selectorCache = new Map();
const clickSelectorCache = new Map();
/**
 * @summary Clear the selector cache. Currently only used for tests.
 */
exports.clearSelectorCache = () => {
    selectorCache.clear();
    clickSelectorCache.clear();
};
exports.toSelector = (selectorParts) => {
    const names = selectorParts.map((s) => s.name);
    // CSS selector
    if (!names.includes('text')) {
        return selectorParts.map((s) => s.body).join(' ');
    }
    // mixed selector
    return selectorParts.map(({ body, name }) => `${name}=${body}`).join(' >> ');
};
exports.buildSelector = (options) => {
    const { isClick, target } = options;
    // To save looping, see if we have already figured out a unique
    // selector for this target.
    let cachedSelectorParts;
    if (isClick) {
        cachedSelectorParts = clickSelectorCache.get(target);
    }
    else {
        cachedSelectorParts = selectorCache.get(target);
    }
    let selector;
    if (cachedSelectorParts) {
        // Even if we have cached a selector, it is possible that the DOM
        // has changed since the cached one was built. Confirm it's a match.
        if (selectorEngine_1.isMatch({ selectorParts: cachedSelectorParts, target })) {
            selector = exports.toSelector(cachedSelectorParts);
            // console.debug('Using cached selector', selector, 'for target', target);
            return selector;
        }
    }
    const cues = cues_1.buildCues(options);
    const { selectorParts } = optimizeCues_1.optimizeCues(cues, target) || {};
    if (selectorParts) {
        // First cache it so that we don't need to do all the looping for this
        // same target next time. We cache `selectorParts` rather than `selector`
        // because the DOM can change, so when we later use the cached selector,
        // we will need to run it through `isMatch` again, which needs the parsed
        // selector.
        if (isClick) {
            clickSelectorCache.set(target, selectorParts);
        }
        else {
            selectorCache.set(target, selectorParts);
        }
        // Now convert selectorParts (a Playwright thing) to a string selector
        selector = exports.toSelector(selectorParts);
    }
    else {
        // No selector was found, fall back to xpath.
        selector = `xpath=${serialize_1.getXpath(target)}`;
    }
    // console.debug('Built selector', selector, 'for target', target);
    return selector;
};
//# sourceMappingURL=selector.js.map