"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressController = exports.setUseApiName = exports.runAbortableTask = void 0;
const errors_1 = require("./errors");
const helper_1 = require("./helper");
const stackTrace_1 = require("./utils/stackTrace");
async function runAbortableTask(task, logger, timeout, apiName) {
    const controller = new ProgressController(logger, timeout, apiName);
    return controller.run(task);
}
exports.runAbortableTask = runAbortableTask;
let useApiName = true;
function setUseApiName(value) {
    useApiName = value;
}
exports.setUseApiName = setUseApiName;
class ProgressController {
    constructor(logger, timeout, apiName) {
        // Promise and callback that forcefully abort the progress.
        // This promise always rejects.
        this._forceAbort = () => { };
        // Promise and callback that resolve once the progress is aborted.
        // This includes the force abort and also rejection of the task itself (failure).
        this._aborted = () => { };
        // Cleanups to be run only in the case of abort.
        this._cleanups = [];
        this._state = 'before';
        this._apiName = apiName;
        this._logger = logger;
        this._timeout = timeout;
        this._deadline = timeout ? monotonicTime() + timeout : 0;
        this._forceAbortPromise = new Promise((resolve, reject) => this._forceAbort = reject);
        this._forceAbortPromise.catch(e => null); // Prevent unhandle promsie rejection.
        this._abortedPromise = new Promise(resolve => this._aborted = resolve);
    }
    async run(task) {
        helper_1.assert(this._state === 'before');
        this._state = 'running';
        const loggerScope = this._logger.createScope(useApiName ? this._apiName : undefined, true);
        const progress = {
            aborted: this._abortedPromise,
            logger: loggerScope,
            timeUntilDeadline: () => this._deadline ? this._deadline - monotonicTime() : 2147483647,
            isRunning: () => this._state === 'running',
            cleanupWhenAborted: (cleanup) => {
                if (this._state === 'running')
                    this._cleanups.push(cleanup);
                else
                    runCleanup(cleanup);
            },
            throwIfAborted: () => {
                if (this._state === 'aborted')
                    throw new AbortedError();
            },
        };
        const timeoutError = new errors_1.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
        const timer = setTimeout(() => this._forceAbort(timeoutError), progress.timeUntilDeadline());
        try {
            const promise = task(progress);
            const result = await Promise.race([promise, this._forceAbortPromise]);
            clearTimeout(timer);
            this._state = 'finished';
            loggerScope.endScope('succeeded');
            return result;
        }
        catch (e) {
            this._aborted();
            stackTrace_1.rewriteErrorMessage(e, (useApiName ? `${this._apiName}: ` : '') +
                e.message +
                formatLogRecording(loggerScope.recording()) +
                kLoggingNote);
            clearTimeout(timer);
            this._state = 'aborted';
            loggerScope.endScope(`failed`);
            await Promise.all(this._cleanups.splice(0).map(cleanup => runCleanup(cleanup)));
            throw e;
        }
    }
    abort(error) {
        this._forceAbort(error);
    }
}
exports.ProgressController = ProgressController;
async function runCleanup(cleanup) {
    try {
        await cleanup();
    }
    catch (e) {
    }
}
const kLoggingNote = `\nNote: use DEBUG=pw:api environment variable and rerun to capture Playwright logs.`;
function formatLogRecording(log) {
    if (!log.length)
        return '';
    const header = ` logs `;
    const headerLength = 60;
    const leftLength = (headerLength - header.length) / 2;
    const rightLength = headerLength - header.length - leftLength;
    return `\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\n${log.join('\n')}\n${'='.repeat(headerLength)}`;
}
function monotonicTime() {
    const [seconds, nanoseconds] = process.hrtime();
    return seconds * 1000 + (nanoseconds / 1000000 | 0);
}
class AbortedError extends Error {
}
//# sourceMappingURL=progress.js.map