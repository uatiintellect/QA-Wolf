"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAttributeTask = exports.innerHTMLTask = exports.innerTextTask = exports.textContentTask = exports.dispatchEventTask = exports.waitForSelectorTask = exports.throwFatalDOMError = exports.toFileTransferPayload = exports.InjectedScriptPollHandler = exports.ElementHandle = exports.FrameExecutionContext = void 0;
const helper_1 = require("./helper");
const injectedScriptSource = require("./generated/injectedScriptSource");
const debugScriptSource = require("./generated/debugScriptSource");
const js = require("./javascript");
const selectors_1 = require("./selectors");
const converters_1 = require("./converters");
class FrameExecutionContext extends js.ExecutionContext {
    constructor(delegate, frame) {
        super(delegate);
        this.frame = frame;
    }
    adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
            return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
    }
    async evaluateInternal(pageFunction, ...args) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluate(this, true /* returnByValue */, pageFunction, ...args);
        });
    }
    async evaluateExpressionInternal(expression, isFunction, ...args) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluateExpression(this, true /* returnByValue */, expression, isFunction, ...args);
        });
    }
    async evaluateHandleInternal(pageFunction, ...args) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluate(this, false /* returnByValue */, pageFunction, ...args);
        });
    }
    async evaluateExpressionHandleInternal(expression, isFunction, ...args) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false /* noWaitFor */, async () => {
            return js.evaluateExpression(this, false /* returnByValue */, expression, isFunction, ...args);
        });
    }
    createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
            return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
    }
    injectedScript() {
        if (!this._injectedScriptPromise) {
            const custom = [];
            for (const [name, { source }] of selectors_1.selectors._engines)
                custom.push(`{ name: '${name}', engine: (${source}) }`);
            const source = `
        new (${injectedScriptSource.source})([
          ${custom.join(',\n')}
        ])
      `;
            this._injectedScriptPromise = this._delegate.rawEvaluate(source).then(objectId => new js.JSHandle(this, 'object', objectId));
        }
        return this._injectedScriptPromise;
    }
    createDebugScript(options) {
        if (!this._debugScriptPromise) {
            const source = `new (${debugScriptSource.source})()`;
            this._debugScriptPromise = this._delegate.rawEvaluate(source).then(objectId => new js.JSHandle(this, 'object', objectId)).then(async (debugScript) => {
                const injectedScript = await this.injectedScript();
                await debugScript.evaluate((debugScript, { injectedScript, options }) => debugScript.initialize(injectedScript, options), { injectedScript, options });
                return debugScript;
            }).catch(e => undefined);
        }
        return this._debugScriptPromise;
    }
}
exports.FrameExecutionContext = FrameExecutionContext;
class ElementHandle extends js.JSHandle {
    constructor(context, objectId) {
        super(context, 'node', objectId);
        this._objectId = objectId;
        this._context = context;
        this._page = context.frame._page;
        this._initializePreview().catch(e => { });
    }
    async _initializePreview() {
        const utility = await this._context.injectedScript();
        this._setPreview(await utility.evaluate((injected, e) => 'JSHandle@' + injected.previewNode(e), this));
    }
    asElement() {
        return this;
    }
    async _evaluateInMain(pageFunction, arg) {
        const main = await this._context.frame._mainContext();
        return main.evaluateInternal(pageFunction, [await main.injectedScript(), this, arg]);
    }
    async _evaluateInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluateInternal(pageFunction, [await utility.injectedScript(), this, arg]);
    }
    async _evaluateHandleInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluateHandleInternal(pageFunction, [await utility.injectedScript(), this, arg]);
    }
    async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
            return null;
        const frame = this._page._frameManager.frame(frameId);
        if (frame)
            return frame;
        for (const page of this._page._browserContext.pages()) {
            const frame = page._frameManager.frame(frameId);
            if (frame)
                return frame;
        }
        return null;
    }
    async contentFrame() {
        const isFrameElement = await this._evaluateInUtility(([injected, node]) => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'), {});
        if (!isFrameElement)
            return null;
        return this._page._delegate.getContentFrame(this);
    }
    async getAttribute(name) {
        return throwFatalDOMError(await this._evaluateInUtility(([injeced, node, name]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'error:notelement';
            const element = node;
            return { value: element.getAttribute(name) };
        }, name)).value;
    }
    async textContent() {
        return this._evaluateInUtility(([injected, node]) => node.textContent, {});
    }
    async innerText() {
        return throwFatalDOMError(await this._evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'error:notelement';
            if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml')
                return 'error:nothtmlelement';
            const element = node;
            return { value: element.innerText };
        }, {})).value;
    }
    async innerHTML() {
        return throwFatalDOMError(await this._evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'error:notelement';
            const element = node;
            return { value: element.innerHTML };
        }, {})).value;
    }
    async dispatchEvent(type, eventInit = {}) {
        await this._evaluateInMain(([injected, node, { type, eventInit }]) => injected.dispatchEvent(node, type, eventInit), { type, eventInit });
    }
    async _scrollRectIntoViewIfNeeded(rect) {
        return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
    }
    async _waitAndScrollIntoViewIfNeeded(progress) {
        while (progress.isRunning()) {
            assertDone(throwRetargetableDOMError(await this._waitForDisplayedAtStablePosition(progress, false /* waitForEnabled */)));
            progress.throwIfAborted(); // Avoid action that has side-effects.
            const result = throwRetargetableDOMError(await this._scrollRectIntoViewIfNeeded());
            if (result === 'error:notvisible')
                continue;
            assertDone(result);
            return;
        }
    }
    async scrollIntoViewIfNeeded(options = {}) {
        return this._page._runAbortableTask(progress => this._waitAndScrollIntoViewIfNeeded(progress), this._page._timeoutSettings.timeout(options), 'elementHandle.scrollIntoViewIfNeeded');
    }
    async _waitForVisible(progress) {
        const poll = await this._evaluateHandleInUtility(([injected, node]) => {
            return injected.waitForNodeVisible(node);
        }, {});
        const pollHandler = new InjectedScriptPollHandler(progress, poll);
        return throwFatalDOMError(await pollHandler.finish());
    }
    async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
            return quad.map(point => ({
                x: Math.min(Math.max(point.x, 0), metrics.width),
                y: Math.min(Math.max(point.y, 0), metrics.height),
            }));
        };
        const computeQuadArea = (quad) => {
            // Compute sum of all directed areas of adjacent triangles
            // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
                const p1 = quad[i];
                const p2 = quad[(i + 1) % quad.length];
                area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([
            this._page._delegate.getContentQuads(this),
            this._page.mainFrame()._utilityContext().then(utility => utility.evaluateInternal(() => ({ width: innerWidth, height: innerHeight }))),
        ]);
        if (!quads || !quads.length)
            return 'error:notvisible';
        const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 1);
        if (!filtered.length)
            return 'error:notinviewport';
        // Return the middle point of the first quad.
        const result = { x: 0, y: 0 };
        for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
        }
        return result;
    }
    async _offsetPoint(offset) {
        const [box, border] = await Promise.all([
            this.boundingBox(),
            this._evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch(e => { }),
        ]);
        if (!box || !border)
            return 'error:notvisible';
        // Make point relative to the padding box to align with offsetX/offsetY.
        return {
            x: box.x + border.left + offset.x,
            y: box.y + border.top + offset.y,
        };
    }
    async _retryPointerAction(progress, actionName, action, options) {
        let first = true;
        while (progress.isRunning()) {
            progress.logger.info(`${first ? 'attempting' : 'retrying'} ${actionName} action`);
            const result = await this._performPointerAction(progress, actionName, action, options);
            first = false;
            if (result === 'error:notvisible') {
                if (options.force)
                    throw new Error('Element is not visible');
                progress.logger.info('  element is not visible');
                continue;
            }
            if (result === 'error:notinviewport') {
                if (options.force)
                    throw new Error('Element is outside of the viewport');
                progress.logger.info('  element is outside of the viewport');
                continue;
            }
            if (result === 'error:nothittarget') {
                if (options.force)
                    throw new Error('Element does not receive pointer events');
                progress.logger.info('  element does not receive pointer events');
                continue;
            }
            return result;
        }
        return 'done';
    }
    async _performPointerAction(progress, actionName, action, options) {
        const { force = false, position } = options;
        if (options.__testHookBeforeStable)
            await options.__testHookBeforeStable();
        if (!force) {
            const result = await this._waitForDisplayedAtStablePosition(progress, true /* waitForEnabled */);
            if (result !== 'done')
                return result;
        }
        if (options.__testHookAfterStable)
            await options.__testHookAfterStable();
        progress.logger.info('  scrolling into view if needed');
        progress.throwIfAborted(); // Avoid action that has side-effects.
        const scrolled = await this._scrollRectIntoViewIfNeeded(position ? { x: position.x, y: position.y, width: 0, height: 0 } : undefined);
        if (scrolled !== 'done')
            return scrolled;
        progress.logger.info('  done scrolling');
        const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
        if (typeof maybePoint === 'string')
            return maybePoint;
        const point = roundPoint(maybePoint);
        if (!force) {
            if (options.__testHookBeforeHitTarget)
                await options.__testHookBeforeHitTarget();
            progress.logger.info(`  checking that element receives pointer events at (${point.x},${point.y})`);
            const hitTargetResult = await this._checkHitTargetAt(point);
            if (hitTargetResult !== 'done')
                return hitTargetResult;
            progress.logger.info(`  element does receive pointer events`);
        }
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            if (options.__testHookBeforePointerAction)
                await options.__testHookBeforePointerAction();
            progress.throwIfAborted(); // Avoid action that has side-effects.
            let restoreModifiers;
            if (options && options.modifiers)
                restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);
            progress.logger.info(`  performing ${actionName} action`);
            await action(point);
            progress.logger.info(`  ${actionName} action done`);
            progress.logger.info('  waiting for scheduled navigations to finish');
            if (options.__testHookAfterPointerAction)
                await options.__testHookAfterPointerAction();
            if (restoreModifiers)
                await this._page.keyboard._ensureModifiers(restoreModifiers);
        }, 'input');
        progress.logger.info('  navigations have finished');
        return 'done';
    }
    hover(options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._hover(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.hover');
    }
    _hover(progress, options) {
        return this._retryPointerAction(progress, 'hover', point => this._page.mouse.move(point.x, point.y), options);
    }
    click(options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._click(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.click');
    }
    _click(progress, options) {
        return this._retryPointerAction(progress, 'click', point => this._page.mouse.click(point.x, point.y, options), options);
    }
    dblclick(options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._dblclick(progress, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.dblclick');
    }
    _dblclick(progress, options) {
        return this._retryPointerAction(progress, 'dblclick', point => this._page.mouse.dblclick(point.x, point.y, options), options);
    }
    async selectOption(values, options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._selectOption(progress, values, options);
            return throwRetargetableDOMError(result);
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.selectOption');
    }
    async _selectOption(progress, values, options) {
        let vals;
        if (values === null)
            vals = [];
        else if (!Array.isArray(values))
            vals = [values];
        else
            vals = values;
        const selectOptions = vals.map((value) => helper_1.helper.isString(value) ? { value } : value);
        for (let i = 0; i < selectOptions.length; i++) {
            const option = selectOptions[i];
            helper_1.assert(option !== null, `options[${i}]: expected object, got null`);
            helper_1.assert(typeof option === 'object', `options[${i}]: expected object, got ${typeof option}`);
            if (option instanceof ElementHandle)
                continue;
            if (option.value !== undefined)
                helper_1.assert(helper_1.helper.isString(option.value), `options[${i}].value: expected string, got ${typeof option.value}`);
            if (option.label !== undefined)
                helper_1.assert(helper_1.helper.isString(option.label), `options[${i}].label: expected string, got ${typeof option.label}`);
            if (option.index !== undefined)
                helper_1.assert(helper_1.helper.isNumber(option.index), `options[${i}].index: expected number, got ${typeof option.index}`);
        }
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            progress.throwIfAborted(); // Avoid action that has side-effects.
            return throwFatalDOMError(await this._evaluateInUtility(([injected, node, selectOptions]) => injected.selectOptions(node, selectOptions), selectOptions));
        });
    }
    async fill(value, options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._fill(progress, value, options);
            assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.fill');
    }
    async _fill(progress, value, options) {
        progress.logger.info(`elementHandle.fill("${value}")`);
        helper_1.assert(helper_1.helper.isString(value), `value: expected string, got ${typeof value}`);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            progress.logger.info('  waiting for element to be visible, enabled and editable');
            const poll = await this._evaluateHandleInUtility(([injected, node, value]) => {
                return injected.waitForEnabledAndFill(node, value);
            }, value);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            const filled = throwFatalDOMError(await pollHandler.finish());
            progress.throwIfAborted(); // Avoid action that has side-effects.
            if (filled === 'error:notconnected')
                return filled;
            progress.logger.info('  element is visible, enabled and editable');
            if (filled === 'needsinput') {
                progress.throwIfAborted(); // Avoid action that has side-effects.
                if (value)
                    await this._page.keyboard.insertText(value);
                else
                    await this._page.keyboard.press('Delete');
            }
            else {
                assertDone(filled);
            }
            return 'done';
        }, 'input');
    }
    async selectText(options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            progress.throwIfAborted(); // Avoid action that has side-effects.
            const poll = await this._evaluateHandleInUtility(([injected, node]) => {
                return injected.waitForVisibleAndSelectText(node);
            }, {});
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            const result = throwFatalDOMError(await pollHandler.finish());
            assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.selectText');
    }
    async setInputFiles(files, options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._setInputFiles(progress, files, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.setInputFiles');
    }
    async _setInputFiles(progress, files, options) {
        const multiple = throwFatalDOMError(await this._evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE || node.tagName !== 'INPUT')
                return 'error:notinput';
            if (!node.isConnected)
                return 'error:notconnected';
            const input = node;
            return input.multiple;
        }, {}));
        if (typeof multiple === 'string')
            return multiple;
        const filePayloads = await converters_1.normalizeFilePayloads(files);
        helper_1.assert(multiple || filePayloads.length <= 1, 'Non-multiple file input can only accept single file!');
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            progress.throwIfAborted(); // Avoid action that has side-effects.
            await this._page._delegate.setInputFiles(this, filePayloads);
        });
        return 'done';
    }
    async focus() {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._focus(progress);
            return assertDone(throwRetargetableDOMError(result));
        }, 0, 'elementHandle.focus');
    }
    async _focus(progress, resetSelectionIfNotFocused) {
        progress.throwIfAborted(); // Avoid action that has side-effects.
        const result = await this._evaluateInUtility(([injected, node, resetSelectionIfNotFocused]) => injected.focusNode(node, resetSelectionIfNotFocused), resetSelectionIfNotFocused);
        return throwFatalDOMError(result);
    }
    async type(text, options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._type(progress, text, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.type');
    }
    async _type(progress, text, options) {
        progress.logger.info(`elementHandle.type("${text}")`);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);
            if (result !== 'done')
                return result;
            progress.throwIfAborted(); // Avoid action that has side-effects.
            await this._page.keyboard.type(text, options);
            return 'done';
        }, 'input');
    }
    async press(key, options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._press(progress, key, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.press');
    }
    async _press(progress, key, options) {
        progress.logger.info(`elementHandle.press("${key}")`);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
            const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);
            if (result !== 'done')
                return result;
            progress.throwIfAborted(); // Avoid action that has side-effects.
            await this._page.keyboard.press(key, options);
            return 'done';
        }, 'input');
    }
    async check(options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._setChecked(progress, true, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.check');
    }
    async uncheck(options = {}) {
        return this._page._runAbortableTask(async (progress) => {
            const result = await this._setChecked(progress, false, options);
            return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options), 'elementHandle.uncheck');
    }
    async _setChecked(progress, state, options) {
        if (await this._evaluateInUtility(([injected, node]) => injected.isCheckboxChecked(node), {}) === state)
            return 'done';
        const result = await this._click(progress, options);
        if (result !== 'done')
            return result;
        if (await this._evaluateInUtility(([injected, node]) => injected.isCheckboxChecked(node), {}) !== state)
            throw new Error('Unable to click checkbox');
        return 'done';
    }
    async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
    }
    async screenshot(options = {}) {
        return this._page._runAbortableTask(progress => this._page._screenshotter.screenshotElement(progress, this, options), this._page._timeoutSettings.timeout(options), 'elementHandle.screenshot');
    }
    async $(selector) {
        return selectors_1.selectors._query(this._context.frame, selector, this);
    }
    async $$(selector) {
        return selectors_1.selectors._queryAll(this._context.frame, selector, this);
    }
    async $eval(selector, pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 3);
        return this._$evalExpression(selector, String(pageFunction), typeof pageFunction === 'function', arg);
    }
    async _$evalExpression(selector, expression, isFunction, arg) {
        const handle = await selectors_1.selectors._query(this._context.frame, selector, this);
        if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle._evaluateExpression(expression, isFunction, true, arg);
        handle.dispose();
        return result;
    }
    async $$eval(selector, pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 3);
        return this._$$evalExpression(selector, String(pageFunction), typeof pageFunction === 'function', arg);
    }
    async _$$evalExpression(selector, expression, isFunction, arg) {
        const arrayHandle = await selectors_1.selectors._queryArray(this._context.frame, selector, this);
        const result = await arrayHandle._evaluateExpression(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
    }
    async _waitForDisplayedAtStablePosition(progress, waitForEnabled) {
        if (waitForEnabled)
            progress.logger.info(`  waiting for element to be visible, enabled and not moving`);
        else
            progress.logger.info(`  waiting for element to be visible and not moving`);
        const rafCount = this._page._delegate.rafCountForStablePosition();
        const poll = this._evaluateHandleInUtility(([injected, node, { rafCount, waitForEnabled }]) => {
            return injected.waitForDisplayedAtStablePosition(node, rafCount, waitForEnabled);
        }, { rafCount, waitForEnabled });
        const pollHandler = new InjectedScriptPollHandler(progress, await poll);
        const result = await pollHandler.finish();
        if (waitForEnabled)
            progress.logger.info('  element is visible, enabled and does not move');
        else
            progress.logger.info('  element is visible and does not move');
        return result;
    }
    async _checkHitTargetAt(point) {
        const frame = await this.ownerFrame();
        if (frame && frame.parentFrame()) {
            const element = await frame.frameElement();
            const box = await element.boundingBox();
            if (!box)
                return 'error:notconnected';
            // Translate from viewport coordinates to frame coordinates.
            point = { x: point.x - box.x, y: point.y - box.y };
        }
        return this._evaluateInUtility(([injected, node, point]) => injected.checkHitTargetAt(node, point), point);
    }
}
exports.ElementHandle = ElementHandle;
// Handles an InjectedScriptPoll running in injected script:
// - streams logs into progress;
// - cancels the poll when progress cancels.
class InjectedScriptPollHandler {
    constructor(progress, poll) {
        this._progress = progress;
        this._poll = poll;
        // Ensure we cancel the poll before progress aborts and returns:
        //   - no unnecessary work in the page;
        //   - no possible side effects after progress promsie rejects.
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
    }
    async _streamLogs() {
        while (this._poll && this._progress.isRunning()) {
            const messages = await this._poll.evaluate(poll => poll.takeNextLogs()).catch(e => []);
            if (!this._poll || !this._progress.isRunning())
                return;
            for (const message of messages)
                this._progress.logger.info(message);
        }
    }
    async finishHandle() {
        try {
            const result = await this._poll.evaluateHandle(poll => poll.result);
            await this._finishInternal();
            return result;
        }
        finally {
            await this.cancel();
        }
    }
    async finish() {
        try {
            const result = await this._poll.evaluate(poll => poll.result);
            await this._finishInternal();
            return result;
        }
        finally {
            await this.cancel();
        }
    }
    async _finishInternal() {
        if (!this._poll)
            return;
        // Retrieve all the logs before continuing.
        const messages = await this._poll.evaluate(poll => poll.takeLastLogs()).catch(e => []);
        for (const message of messages)
            this._progress.logger.info(message);
    }
    async cancel() {
        if (!this._poll)
            return;
        const copy = this._poll;
        this._poll = null;
        await copy.evaluate(p => p.cancel()).catch(e => { });
        copy.dispose();
    }
}
exports.InjectedScriptPollHandler = InjectedScriptPollHandler;
function toFileTransferPayload(files) {
    return files.map(file => ({
        name: file.name,
        type: file.mimeType,
        data: file.buffer.toString('base64')
    }));
}
exports.toFileTransferPayload = toFileTransferPayload;
function throwFatalDOMError(result) {
    if (result === 'error:notelement')
        throw new Error('Node is not an element');
    if (result === 'error:nothtmlelement')
        throw new Error('Not an HTMLElement');
    if (result === 'error:notfillableelement')
        throw new Error('Element is not an <input>, <textarea> or [contenteditable] element');
    if (result === 'error:notfillableinputtype')
        throw new Error('Input of this type cannot be filled');
    if (result === 'error:notfillablenumberinput')
        throw new Error('Cannot type text into input[type=number]');
    if (result === 'error:notvaliddate')
        throw new Error(`Malformed value`);
    if (result === 'error:notinput')
        throw new Error('Node is not an HTMLInputElement');
    if (result === 'error:notselect')
        throw new Error('Element is not a <select> element.');
    return result;
}
exports.throwFatalDOMError = throwFatalDOMError;
function throwRetargetableDOMError(result) {
    if (result === 'error:notconnected')
        throw new Error('Element is not attached to the DOM');
    return result;
}
function assertDone(result) {
    // This function converts 'done' to void and ensures typescript catches unhandled errors.
}
function roundPoint(point) {
    return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100,
    };
}
function waitForSelectorTask(selector, state) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, state }) => {
        let lastElement;
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            const visible = element ? injected.isVisible(element) : false;
            if (lastElement !== element) {
                lastElement = element;
                if (!element)
                    progress.log(`  selector did not resolve to any element`);
                else
                    progress.log(`  selector resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`);
            }
            switch (state) {
                case 'attached':
                    return element ? element : continuePolling;
                case 'detached':
                    return !element ? undefined : continuePolling;
                case 'visible':
                    return visible ? element : continuePolling;
                case 'hidden':
                    return !visible ? undefined : continuePolling;
            }
        });
    }, { parsed: selector.parsed, state });
}
exports.waitForSelectorTask = waitForSelectorTask;
function dispatchEventTask(selector, type, eventInit) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, type, eventInit }) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            injected.dispatchEvent(element, type, eventInit);
        });
    }, { parsed: selector.parsed, type, eventInit });
}
exports.dispatchEventTask = dispatchEventTask;
function textContentTask(selector) {
    return injectedScript => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return element.textContent;
        });
    }, selector.parsed);
}
exports.textContentTask = textContentTask;
function innerTextTask(selector) {
    return injectedScript => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            if (element.namespaceURI !== 'http://www.w3.org/1999/xhtml')
                return 'error:nothtmlelement';
            return { innerText: element.innerText };
        });
    }, selector.parsed);
}
exports.innerTextTask = innerTextTask;
function innerHTMLTask(selector) {
    return injectedScript => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return element.innerHTML;
        });
    }, selector.parsed);
}
exports.innerHTMLTask = innerHTMLTask;
function getAttributeTask(selector, name) {
    return injectedScript => injectedScript.evaluateHandle((injected, { parsed, name }) => {
        return injected.pollRaf((progress, continuePolling) => {
            const element = injected.querySelector(parsed, document);
            if (!element)
                return continuePolling;
            progress.log(`  selector resolved to ${injected.previewNode(element)}`);
            return element.getAttribute(name);
        });
    }, { parsed: selector.parsed, name });
}
exports.getAttributeTask = getAttributeTask;
//# sourceMappingURL=dom.js.map