"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Electron = exports.ElectronApplication = exports.ElectronEvents = void 0;
const path = require("path");
const crBrowser_1 = require("../chromium/crBrowser");
const crConnection_1 = require("../chromium/crConnection");
const crExecutionContext_1 = require("../chromium/crExecutionContext");
const events_1 = require("../events");
const js = require("../javascript");
const logger_1 = require("../logger");
const timeoutSettings_1 = require("../timeoutSettings");
const transport_1 = require("../transport");
const browserServer_1 = require("./browserServer");
const processLauncher_1 = require("./processLauncher");
const progress_1 = require("../progress");
const events_2 = require("events");
const helper_1 = require("../helper");
exports.ElectronEvents = {
    ElectronApplication: {
        Close: 'close',
        Window: 'window',
    }
};
class ElectronApplication extends events_2.EventEmitter {
    constructor(logger, browser, nodeConnection) {
        super();
        this._windows = new Set();
        this._lastWindowId = 0;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._apiLogger = logger.api;
        this._browserContext = browser._defaultContext;
        this._browserContext.on(events_1.Events.BrowserContext.Close, () => {
            // Emit application closed after context closed.
            Promise.resolve().then(() => this.emit(exports.ElectronEvents.ElectronApplication.Close));
        });
        this._browserContext.on(events_1.Events.BrowserContext.Page, event => this._onPage(event));
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
    }
    async _onPage(page) {
        // Needs to be sync.
        const windowId = ++this._lastWindowId;
        // Can be async.
        const handle = await this._nodeElectronHandle.evaluateHandle(({ BrowserWindow }, windowId) => BrowserWindow.fromId(windowId), windowId).catch(e => { });
        if (!handle)
            return;
        page.browserWindow = handle;
        page._browserWindowId = windowId;
        page.on(events_1.Events.Page.Close, () => {
            page.browserWindow.dispose();
            this._windows.delete(page);
        });
        this._windows.add(page);
        await page.waitForLoadState('domcontentloaded').catch(e => { }); // can happen after detach
        this.emit(exports.ElectronEvents.ElectronApplication.Window, page);
    }
    windows() {
        return [...this._windows];
    }
    async firstWindow() {
        if (this._windows.size)
            return this._windows.values().next().value;
        return this.waitForEvent('window');
    }
    async newBrowserWindow(options) {
        const windowId = await this.evaluate(async ({ BrowserWindow }, options) => {
            const win = new BrowserWindow(options);
            win.loadURL('about:blank');
            return win.id;
        }, options);
        for (const page of this._windows) {
            if (page._browserWindowId === windowId)
                return page;
        }
        return await this.waitForEvent(exports.ElectronEvents.ElectronApplication.Window, (page) => page._browserWindowId === windowId);
    }
    context() {
        return this._browserContext;
    }
    async close() {
        const closed = this.waitForEvent(exports.ElectronEvents.ElectronApplication.Close);
        await this.evaluate(({ app }) => app.quit());
        this._nodeConnection.close();
        await closed;
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        const options = typeof optionsOrPredicate === 'function' ? { predicate: optionsOrPredicate } : optionsOrPredicate;
        const progressController = new progress_1.ProgressController(this._apiLogger, this._timeoutSettings.timeout(options), 'electron.waitForEvent');
        if (event !== exports.ElectronEvents.ElectronApplication.Close)
            this._browserContext._closePromise.then(error => progressController.abort(error));
        return progressController.run(progress => helper_1.helper.waitForEvent(progress, this, event, options.predicate).promise);
    }
    async _init() {
        this._nodeSession.once('Runtime.executionContextCreated', event => {
            this._nodeExecutionContext = new js.ExecutionContext(new crExecutionContext_1.CRExecutionContext(this._nodeSession, event.context));
        });
        await this._nodeSession.send('Runtime.enable', {}).catch(e => { });
        this._nodeElectronHandle = await js.evaluate(this._nodeExecutionContext, false /* returnByValue */, () => {
            // Resolving the race between the debugger and the boot-time script.
            if (global._playwrightRun)
                return global._playwrightRun();
            return new Promise(f => global._playwrightRunCallback = f);
        });
    }
    async evaluate(pageFunction, arg) {
        return this._nodeElectronHandle.evaluate(pageFunction, arg);
    }
    async evaluateHandle(pageFunction, arg) {
        return this._nodeElectronHandle.evaluateHandle(pageFunction, arg);
    }
}
exports.ElectronApplication = ElectronApplication;
class Electron {
    async launch(executablePath, options = {}) {
        const { args = [], env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, } = options;
        const loggers = new logger_1.Loggers(options.logger);
        return progress_1.runAbortableTask(async (progress) => {
            let app = undefined;
            const electronArguments = ['--inspect=0', '--remote-debugging-port=0', '--require', path.join(__dirname, 'electronLoader.js'), ...args];
            const { launchedProcess, gracefullyClose, kill } = await processLauncher_1.launchProcess({
                executablePath,
                args: electronArguments,
                env,
                handleSIGINT,
                handleSIGTERM,
                handleSIGHUP,
                progress,
                pipe: true,
                cwd: options.cwd,
                tempDirectories: [],
                attemptToGracefullyClose: () => app.close(),
                onExit: (exitCode, signal) => { },
            });
            const nodeMatch = await processLauncher_1.waitForLine(progress, launchedProcess, launchedProcess.stderr, /^Debugger listening on (ws:\/\/.*)$/);
            const nodeTransport = await transport_1.WebSocketTransport.connect(progress, nodeMatch[1]);
            const nodeConnection = new crConnection_1.CRConnection(nodeTransport, loggers);
            const chromeMatch = await processLauncher_1.waitForLine(progress, launchedProcess, launchedProcess.stderr, /^DevTools listening on (ws:\/\/.*)$/);
            const chromeTransport = await transport_1.WebSocketTransport.connect(progress, chromeMatch[1]);
            const browserServer = new browserServer_1.BrowserServer(launchedProcess, gracefullyClose, kill);
            const browser = await crBrowser_1.CRBrowser.connect(chromeTransport, { name: 'electron', headful: true, loggers, persistent: { viewport: null }, ownedServer: browserServer });
            app = new ElectronApplication(loggers, browser, nodeConnection);
            await app._init();
            return app;
        }, loggers.browser, timeoutSettings_1.TimeoutSettings.timeout(options), 'electron.launch');
    }
}
exports.Electron = Electron;
//# sourceMappingURL=electron.js.map