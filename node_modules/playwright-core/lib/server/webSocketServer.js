"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketServer = void 0;
const ws = require("ws");
const helper_1 = require("../helper");
const logger_1 = require("../logger");
class WebSocketServer {
    constructor(transport, logger, port, delegate) {
        this._bindings = [];
        this._lastSeqNum = 0;
        this._sockets = new Set();
        this._pendingRequests = new Map();
        this._guid = helper_1.helper.guid();
        this._transport = transport;
        this._logger = logger;
        this._server = new ws.Server({ port });
        this._delegate = delegate;
        transport.onmessage = message => this._browserMessage(message);
        transport.onclose = () => this._browserClosed();
        this._server.on('connection', (socket, req) => this._clientAttached(socket, req));
        const address = this._server.address();
        this.wsEndpoint = typeof address === 'string' ? `${address}/${this._guid}` : `ws://127.0.0.1:${address.port}/${this._guid}`;
    }
    addBindings(bindings) {
        this._bindings.push(...bindings);
    }
    sendMessageToBrowser(message, source) {
        const seqNum = ++this._lastSeqNum;
        this._pendingRequests.set(seqNum, { message, source });
        this._transport.send({ ...message, id: seqNum });
        return seqNum;
    }
    sendMessageToBrowserOneWay(method, params) {
        this._transport.send({ id: ++this._lastSeqNum, method, params });
    }
    close() {
        this._server.close();
    }
    _browserMessage(message) {
        const seqNum = message.id;
        if (typeof seqNum === 'number') {
            const request = this._pendingRequests.get(seqNum);
            if (!request)
                return;
            this._pendingRequests.delete(seqNum);
            message.id = request.message.id;
            if (request.source)
                this._delegate.onBrowserResponse(seqNum, request.source, message);
        }
        else {
            this._delegate.onBrowserNotification(message);
        }
    }
    _browserClosed() {
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        for (const socket of this._sockets) {
            socket.removeAllListeners('close');
            socket.close(undefined, 'Browser disconnected');
        }
        this._server.close();
    }
    _clientAttached(socket, req) {
        if (req.url !== '/' + this._guid) {
            socket.close();
            return;
        }
        this._sockets.add(socket);
        this._delegate.onClientAttached(socket);
        socket.on('message', (message) => {
            const parsedMessage = JSON.parse(Buffer.from(message).toString());
            this._delegate.onClientRequest(socket, parsedMessage);
        });
        socket.on('error', logger_1.logError(this._logger));
        socket.on('close', () => {
            this._delegate.onClientDetached(socket);
            this._sockets.delete(socket);
        });
    }
    async checkLeaks() {
        let counter = 0;
        return new Promise((fulfill, reject) => {
            const check = () => {
                const filtered = this._bindings.filter(entry => entry.size);
                if (!filtered.length) {
                    fulfill();
                    return;
                }
                if (++counter >= 50) {
                    reject(new Error('Web socket leak ' + filtered.map(entry => [...entry.keys()].join(':')).join('|')));
                    return;
                }
                setTimeout(check, 100);
            };
            check();
        });
    }
}
exports.WebSocketServer = WebSocketServer;
//# sourceMappingURL=webSocketServer.js.map