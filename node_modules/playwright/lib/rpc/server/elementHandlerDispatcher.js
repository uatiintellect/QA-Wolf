"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertInputFiles = exports.convertSelectOptionValues = exports.ElementHandleDispatcher = exports.createHandle = void 0;
const dispatcher_1 = require("./dispatcher");
const jsHandleDispatcher_1 = require("./jsHandleDispatcher");
function createHandle(scope, handle) {
    return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new jsHandleDispatcher_1.JSHandleDispatcher(scope, handle);
}
exports.createHandle = createHandle;
class ElementHandleDispatcher extends jsHandleDispatcher_1.JSHandleDispatcher {
    constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._elementHandle = elementHandle;
    }
    static createNullable(scope, handle) {
        if (!handle)
            return undefined;
        return new ElementHandleDispatcher(scope, handle);
    }
    async ownerFrame() {
        return { frame: dispatcher_1.lookupNullableDispatcher(await this._elementHandle.ownerFrame()) };
    }
    async contentFrame() {
        return { frame: dispatcher_1.lookupNullableDispatcher(await this._elementHandle.contentFrame()) };
    }
    async getAttribute(params) {
        const value = await this._elementHandle.getAttribute(params.name);
        return { value: value === null ? undefined : value };
    }
    async textContent() {
        const value = await this._elementHandle.textContent();
        return { value: value === null ? undefined : value };
    }
    async innerText() {
        return { value: await this._elementHandle.innerText() };
    }
    async innerHTML() {
        return { value: await this._elementHandle.innerHTML() };
    }
    async dispatchEvent(params) {
        await this._elementHandle.dispatchEvent(params.type, jsHandleDispatcher_1.parseArgument(params.eventInit));
    }
    async scrollIntoViewIfNeeded(params) {
        await this._elementHandle.scrollIntoViewIfNeeded(params);
    }
    async hover(params) {
        await this._elementHandle.hover(params);
    }
    async click(params) {
        await this._elementHandle.click(params);
    }
    async dblclick(params) {
        await this._elementHandle.dblclick(params);
    }
    async selectOption(params) {
        return { values: await this._elementHandle.selectOption(convertSelectOptionValues(params.elements, params.options), params) };
    }
    async fill(params) {
        await this._elementHandle.fill(params.value, params);
    }
    async selectText(params) {
        await this._elementHandle.selectText(params);
    }
    async setInputFiles(params) {
        await this._elementHandle.setInputFiles(convertInputFiles(params.files), params);
    }
    async focus() {
        await this._elementHandle.focus();
    }
    async type(params) {
        await this._elementHandle.type(params.text, params);
    }
    async press(params) {
        await this._elementHandle.press(params.key, params);
    }
    async check(params) {
        await this._elementHandle.check(params);
    }
    async uncheck(params) {
        await this._elementHandle.uncheck(params);
    }
    async boundingBox() {
        const value = await this._elementHandle.boundingBox();
        return { value: value || undefined };
    }
    async screenshot(params) {
        return { binary: (await this._elementHandle.screenshot(params)).toString('base64') };
    }
    async querySelector(params) {
        const handle = await this._elementHandle.$(params.selector);
        return { element: handle ? new ElementHandleDispatcher(this._scope, handle) : undefined };
    }
    async querySelectorAll(params) {
        const elements = await this._elementHandle.$$(params.selector);
        return { elements: elements.map(e => new ElementHandleDispatcher(this._scope, e)) };
    }
    async evalOnSelector(params) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._elementHandle._$evalExpression(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evalOnSelectorAll(params) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._elementHandle._$$evalExpression(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
}
exports.ElementHandleDispatcher = ElementHandleDispatcher;
function convertSelectOptionValues(elements, options) {
    if (elements)
        return elements.map(v => v._elementHandle);
    if (options)
        return options;
    return null;
}
exports.convertSelectOptionValues = convertSelectOptionValues;
function convertInputFiles(files) {
    return files.map(f => ({ name: f.name, mimeType: f.mimeType, buffer: Buffer.from(f.buffer, 'base64') }));
}
exports.convertInputFiles = convertInputFiles;
//# sourceMappingURL=elementHandlerDispatcher.js.map