"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyProxySettings = exports.verifyGeolocation = exports.validateBrowserContextOptions = exports.assertBrowserContextIsNotOwned = exports.BrowserContextBase = void 0;
const helper_1 = require("./helper");
const network = require("./network");
const page_1 = require("./page");
const timeoutSettings_1 = require("./timeoutSettings");
const events_1 = require("./events");
const logger_1 = require("./logger");
const events_2 = require("events");
const progress_1 = require("./progress");
const debugController_1 = require("./debug/debugController");
class BrowserContextBase extends events_2.EventEmitter {
    constructor(browserBase, options, isPersistentContext) {
        super();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._pageBindings = new Map();
        this._routes = [];
        this._closedStatus = 'open';
        this._permissions = new Map();
        this._downloads = new Set();
        this._browserBase = browserBase;
        this._options = options;
        const loggers = options.logger ? new logger_1.Loggers(options.logger) : browserBase._options.loggers;
        this._apiLogger = loggers.api;
        this._isPersistentContext = isPersistentContext;
        this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);
    }
    async _initialize() {
        if (helper_1.helper.isDebugMode())
            new debugController_1.DebugController(this);
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        const options = typeof optionsOrPredicate === 'function' ? { predicate: optionsOrPredicate } : optionsOrPredicate;
        const progressController = new progress_1.ProgressController(this._apiLogger, this._timeoutSettings.timeout(options), 'browserContext.waitForEvent');
        if (event !== events_1.Events.BrowserContext.Close)
            this._closePromise.then(error => progressController.abort(error));
        return progressController.run(progress => helper_1.helper.waitForEvent(progress, this, event, options.predicate).promise);
    }
    _browserClosed() {
        for (const page of this.pages())
            page._didClose();
        this._didCloseInternal();
    }
    _didCloseInternal() {
        if (this._closedStatus === 'closed') {
            // We can come here twice if we close browser context and browser
            // at the same time.
            return;
        }
        this._closedStatus = 'closed';
        this._downloads.clear();
        this._closePromiseFulfill(new Error('Context closed'));
        this.emit(events_1.Events.BrowserContext.Close);
    }
    async cookies(urls = []) {
        if (urls && !Array.isArray(urls))
            urls = [urls];
        return await this._doCookies(urls);
    }
    async exposeFunction(name, playwrightFunction) {
        await this.exposeBinding(name, (options, ...args) => playwrightFunction(...args));
    }
    setHTTPCredentials(httpCredentials) {
        if (!helper_1.isUnderTest())
            helper_1.deprecate(`context.setHTTPCredentials`, `warning: method |context.setHTTPCredentials()| is deprecated. Instead of changing credentials, create another browser context with new credentials.`);
        return this._doSetHTTPCredentials(httpCredentials);
    }
    async exposeBinding(name, playwrightBinding) {
        for (const page of this.pages()) {
            if (page._pageBindings.has(name))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
        const binding = new page_1.PageBinding(name, playwrightBinding);
        this._pageBindings.set(name, binding);
        this._doExposeBinding(binding);
    }
    async addInitScript(script, arg) {
        const source = await helper_1.helper.evaluationScript(script, arg);
        await this._doAddInitScript(source);
    }
    async grantPermissions(permissions, options) {
        let origin = '*';
        if (options && options.origin) {
            const url = new URL(options.origin);
            origin = url.origin;
        }
        const existing = new Set(this._permissions.get(origin) || []);
        permissions.forEach(p => existing.add(p));
        const list = [...existing.values()];
        this._permissions.set(origin, list);
        await this._doGrantPermissions(origin, list);
    }
    async clearPermissions() {
        this._permissions.clear();
        await this._doClearPermissions();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async _loadDefaultContext() {
        if (!this.pages().length)
            await this.waitForEvent('page');
        const pages = this.pages();
        await pages[0].waitForLoadState();
        if (pages.length !== 1 || pages[0].url() !== 'about:blank')
            throw new Error(`Arguments can not specify page to be opened (first url is ${pages[0].url()})`);
        if (this._options.isMobile || this._options.locale) {
            // Workaround for:
            // - chromium fails to change isMobile for existing page;
            // - webkit fails to change locale for existing page.
            const oldPage = pages[0];
            await this.newPage();
            await oldPage.close();
        }
    }
    _authenticateProxyViaHeader() {
        const proxy = this._browserBase._options.proxy || { username: undefined, password: undefined };
        const { username, password } = proxy;
        if (username) {
            this._options.httpCredentials = { username, password: password };
            this._options.extraHTTPHeaders = this._options.extraHTTPHeaders || {};
            const token = Buffer.from(`${username}:${password}`).toString('base64');
            this._options.extraHTTPHeaders['Proxy-Authorization'] = `Basic ${token}`;
        }
    }
    _authenticateProxyViaCredentials() {
        const proxy = this._browserBase._options.proxy;
        if (!proxy)
            return;
        const { username, password } = proxy;
        if (username && password)
            this._options.httpCredentials = { username, password };
    }
    async close() {
        if (this._isPersistentContext) {
            // Default context is only created in 'persistent' mode and closing it should close
            // the browser.
            await this._browserBase.close();
            return;
        }
        if (this._closedStatus === 'open') {
            this._closedStatus = 'closing';
            await this._doClose();
            await Promise.all([...this._downloads].map(d => d.delete()));
            this._didCloseInternal();
        }
        await this._closePromise;
    }
}
exports.BrowserContextBase = BrowserContextBase;
function assertBrowserContextIsNotOwned(context) {
    for (const page of context.pages()) {
        if (page._ownedContext)
            throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');
    }
}
exports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
function validateBrowserContextOptions(options) {
    // Copy all fields manually to strip any extra junk.
    // Especially useful when we share context and launch options for launchPersistent.
    const result = {
        ignoreHTTPSErrors: options.ignoreHTTPSErrors,
        bypassCSP: options.bypassCSP,
        locale: options.locale,
        timezoneId: options.timezoneId,
        offline: options.offline,
        colorScheme: options.colorScheme,
        acceptDownloads: options.acceptDownloads,
        viewport: options.viewport,
        javaScriptEnabled: options.javaScriptEnabled,
        userAgent: options.userAgent,
        geolocation: options.geolocation,
        permissions: options.permissions,
        extraHTTPHeaders: options.extraHTTPHeaders,
        httpCredentials: options.httpCredentials,
        deviceScaleFactor: options.deviceScaleFactor,
        isMobile: options.isMobile,
        hasTouch: options.hasTouch,
        logger: options.logger,
    };
    if (result.viewport === null && result.deviceScaleFactor !== undefined)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
    if (result.viewport === null && result.isMobile !== undefined)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
    if (!result.viewport && result.viewport !== null)
        result.viewport = { width: 1280, height: 720 };
    if (result.viewport)
        result.viewport = { ...result.viewport };
    if (result.geolocation)
        result.geolocation = verifyGeolocation(result.geolocation);
    if (result.extraHTTPHeaders)
        result.extraHTTPHeaders = network.verifyHeaders(result.extraHTTPHeaders);
    return result;
}
exports.validateBrowserContextOptions = validateBrowserContextOptions;
function verifyGeolocation(geolocation) {
    const result = { ...geolocation };
    result.accuracy = result.accuracy || 0;
    const { longitude, latitude, accuracy } = result;
    if (!helper_1.helper.isNumber(longitude))
        throw new Error(`geolocation.longitude: expected number, got ${typeof longitude}`);
    if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
    if (!helper_1.helper.isNumber(latitude))
        throw new Error(`geolocation.latitude: expected number, got ${typeof latitude}`);
    if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
    if (!helper_1.helper.isNumber(accuracy))
        throw new Error(`geolocation.accuracy: expected number, got ${typeof accuracy}`);
    if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
    return result;
}
exports.verifyGeolocation = verifyGeolocation;
function verifyProxySettings(proxy) {
    let { server, bypass } = proxy;
    if (!helper_1.helper.isString(server))
        throw new Error(`Invalid proxy.server: ` + server);
    let url = new URL(server);
    if (!['http:', 'https:', 'socks5:'].includes(url.protocol)) {
        url = new URL('http://' + server);
        server = `${url.protocol}//${url.host}`;
    }
    if (bypass)
        bypass = bypass.split(',').map(t => t.trim()).join(',');
    return { ...proxy, server, bypass };
}
exports.verifyProxySettings = verifyProxySettings;
//# sourceMappingURL=browserContext.js.map