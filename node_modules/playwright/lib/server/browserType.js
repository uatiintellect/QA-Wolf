"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserTypeBase = void 0;
const fs = require("fs");
const os = require("os");
const path = require("path");
const util = require("util");
const browserContext_1 = require("../browserContext");
const browserServer_1 = require("./browserServer");
const browserPaths = require("../install/browserPaths");
const logger_1 = require("../logger");
const transport_1 = require("../transport");
const helper_1 = require("../helper");
const processLauncher_1 = require("./processLauncher");
const events_1 = require("../events");
const pipeTransport_1 = require("./pipeTransport");
const progress_1 = require("../progress");
const timeoutSettings_1 = require("../timeoutSettings");
const validateDependencies_1 = require("./validateDependencies");
const mkdirAsync = util.promisify(fs.mkdir);
const mkdtempAsync = util.promisify(fs.mkdtemp);
const existsAsync = (path) => new Promise(resolve => fs.stat(path, err => resolve(!err)));
const DOWNLOADS_FOLDER = path.join(os.tmpdir(), 'playwright_downloads-');
class BrowserTypeBase {
    constructor(packagePath, browser, webSocketOrPipe) {
        this._name = browser.name;
        const browsersPath = browserPaths.browsersPath(packagePath);
        this._browserDescriptor = browser;
        this._browserPath = browserPaths.browserDirectory(browsersPath, browser);
        this._executablePath = browserPaths.executablePath(this._browserPath, browser);
        this._webSocketNotPipe = webSocketOrPipe;
    }
    executablePath() {
        if (!this._executablePath)
            throw new Error('Browser is not supported on current platform');
        return this._executablePath;
    }
    name() {
        return this._name;
    }
    async launch(options = {}) {
        helper_1.assert(!options.userDataDir, 'userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead');
        helper_1.assert(!options.port, 'Cannot specify a port without launching as a server.');
        options = validateLaunchOptions(options);
        const loggers = new logger_1.Loggers(options.logger);
        const label = 'browserType.launch';
        const browser = await progress_1.runAbortableTask(progress => this._innerLaunch(progress, options, loggers, undefined), loggers.browser, timeoutSettings_1.TimeoutSettings.timeout(options), label).catch(e => { throw this._rewriteStartupError(e, label); });
        return browser;
    }
    async launchPersistentContext(userDataDir, options = {}) {
        helper_1.assert(!options.port, 'Cannot specify a port without launching as a server.');
        options = validateLaunchOptions(options);
        const persistent = browserContext_1.validateBrowserContextOptions(options);
        const loggers = new logger_1.Loggers(options.logger);
        const label = 'browserType.launchPersistentContext';
        const browser = await progress_1.runAbortableTask(progress => this._innerLaunch(progress, options, loggers, persistent, userDataDir), loggers.browser, timeoutSettings_1.TimeoutSettings.timeout(options), label).catch(e => { throw this._rewriteStartupError(e, label); });
        return browser._defaultContext;
    }
    async _innerLaunch(progress, options, logger, persistent, userDataDir) {
        options.proxy = options.proxy ? browserContext_1.verifyProxySettings(options.proxy) : undefined;
        const { browserServer, downloadsPath, transport } = await this._launchServer(progress, options, !!persistent, logger, userDataDir);
        if (options.__testHookBeforeCreateBrowser)
            await options.__testHookBeforeCreateBrowser();
        const browserOptions = {
            name: this._name,
            slowMo: options.slowMo,
            persistent,
            headful: !options.headless,
            loggers: logger,
            downloadsPath,
            ownedServer: browserServer,
            proxy: options.proxy,
        };
        copyTestHooks(options, browserOptions);
        const browser = await this._connectToTransport(transport, browserOptions);
        // We assume no control when using custom arguments, and do not prepare the default context in that case.
        const hasCustomArguments = !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs);
        if (persistent && !hasCustomArguments)
            await browser._defaultContext._loadDefaultContext();
        return browser;
    }
    async launchServer(options = {}) {
        helper_1.assert(!options.userDataDir, 'userDataDir option is not supported in `browserType.launchServer`. Use `browserType.launchPersistentContext` instead');
        options = validateLaunchOptions(options);
        const loggers = new logger_1.Loggers(options.logger);
        const { port = 0 } = options;
        return progress_1.runAbortableTask(async (progress) => {
            const { browserServer, transport } = await this._launchServer(progress, options, false, loggers);
            browserServer._webSocketServer = this._startWebSocketServer(transport, loggers.browser, port);
            return browserServer;
        }, loggers.browser, timeoutSettings_1.TimeoutSettings.timeout(options), 'browserType.launchServer');
    }
    async connect(options) {
        const loggers = new logger_1.Loggers(options.logger);
        return progress_1.runAbortableTask(async (progress) => {
            const transport = await transport_1.WebSocketTransport.connect(progress, options.wsEndpoint);
            progress.cleanupWhenAborted(() => transport.closeAndWait());
            if (options.__testHookBeforeCreateBrowser)
                await options.__testHookBeforeCreateBrowser();
            const browser = await this._connectToTransport(transport, { name: this._name, slowMo: options.slowMo, loggers });
            return browser;
        }, loggers.browser, timeoutSettings_1.TimeoutSettings.timeout(options), 'browserType.connect');
    }
    async _launchServer(progress, options, isPersistent, loggers, userDataDir) {
        const { ignoreDefaultArgs = false, args = [], executablePath = null, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, } = options;
        const tempDirectories = [];
        let downloadsPath;
        if (options.downloadsPath) {
            downloadsPath = options.downloadsPath;
            await mkdirAsync(options.downloadsPath, { recursive: true });
        }
        else {
            downloadsPath = await mkdtempAsync(DOWNLOADS_FOLDER);
            tempDirectories.push(downloadsPath);
        }
        if (!userDataDir) {
            userDataDir = await mkdtempAsync(path.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
            tempDirectories.push(userDataDir);
        }
        const browserArguments = [];
        if (!ignoreDefaultArgs)
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));
        else if (Array.isArray(ignoreDefaultArgs))
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter(arg => ignoreDefaultArgs.indexOf(arg) === -1));
        else
            browserArguments.push(...args);
        const executable = executablePath || this.executablePath();
        if (!executable)
            throw new Error(`No executable path is specified. Pass "executablePath" option directly.`);
        if (!(await existsAsync(executable))) {
            const errorMessageLines = [`Failed to launch ${this._name} because executable doesn't exist at ${executable}`];
            // If we tried using stock downloaded browser, suggest re-installing playwright.
            if (!executablePath)
                errorMessageLines.push(`Try re-installing playwright with "npm install playwright"`);
            throw new Error(errorMessageLines.join('\n'));
        }
        if (!executablePath) {
            // We can only validate dependencies for bundled browsers.
            await validateDependencies_1.validateHostRequirements(this._browserPath, this._browserDescriptor);
        }
        // Note: it is important to define these variables before launchProcess, so that we don't get
        // "Cannot access 'browserServer' before initialization" if something went wrong.
        let transport = undefined;
        let browserServer = undefined;
        const { launchedProcess, gracefullyClose, kill } = await processLauncher_1.launchProcess({
            executablePath: executable,
            args: this._amendArguments(browserArguments),
            env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
            handleSIGINT,
            handleSIGTERM,
            handleSIGHUP,
            progress,
            pipe: !this._webSocketNotPipe,
            tempDirectories,
            attemptToGracefullyClose: async () => {
                if (options.__testHookGracefullyClose)
                    await options.__testHookGracefullyClose();
                // We try to gracefully close to prevent crash reporting and core dumps.
                // Note that it's fine to reuse the pipe transport, since
                // our connection ignores kBrowserCloseMessageId.
                this._attemptToGracefullyCloseBrowser(transport);
            },
            onExit: (exitCode, signal) => {
                if (browserServer)
                    browserServer.emit(events_1.Events.BrowserServer.Close, exitCode, signal);
            },
        });
        browserServer = new browserServer_1.BrowserServer(launchedProcess, gracefullyClose, kill);
        progress.cleanupWhenAborted(() => browserServer && browserServer._closeOrKill(progress.timeUntilDeadline()));
        if (this._webSocketNotPipe) {
            const match = await processLauncher_1.waitForLine(progress, launchedProcess, this._webSocketNotPipe.stream === 'stdout' ? launchedProcess.stdout : launchedProcess.stderr, this._webSocketNotPipe.webSocketRegex);
            const innerEndpoint = match[1];
            transport = await transport_1.WebSocketTransport.connect(progress, innerEndpoint);
        }
        else {
            const stdio = launchedProcess.stdio;
            transport = new pipeTransport_1.PipeTransport(stdio[3], stdio[4], loggers.browser);
        }
        return { browserServer, downloadsPath, transport };
    }
}
exports.BrowserTypeBase = BrowserTypeBase;
function copyTestHooks(from, to) {
    for (const [key, value] of Object.entries(from)) {
        if (key.startsWith('__testHook'))
            to[key] = value;
    }
}
function validateLaunchOptions(options) {
    const { devtools = false, headless = !helper_1.helper.isDebugMode() && !devtools } = options;
    return { ...options, devtools, headless };
}
//# sourceMappingURL=browserType.js.map