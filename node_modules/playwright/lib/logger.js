"use strict";
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugLoggerSink = exports.Loggers = exports.Logger = exports.logError = void 0;
const debug = require("debug");
const fs = require("fs");
const helper_1 = require("./helper");
function logError(logger) {
    return error => logger.error(error);
}
exports.logError = logError;
class Logger {
    constructor(loggerSink, name, hints, scopeName, record) {
        this._loggerSink = loggerSink;
        this._name = name;
        this._hints = hints;
        this._scopeName = scopeName;
        if (record)
            this._recording = [];
    }
    isEnabled(severity) {
        return this._loggerSink.isEnabled(this._name, severity || 'info');
    }
    verbose(message, ...args) {
        return this._innerLog('verbose', message, args);
    }
    info(message, ...args) {
        return this._innerLog('info', message, args);
    }
    warn(message, ...args) {
        return this._innerLog('warning', message, args);
    }
    error(message, ...args) {
        return this._innerLog('error', message, args);
    }
    createScope(scopeName, record) {
        if (scopeName)
            this._loggerSink.log(this._name, 'info', `=> ${scopeName} started`, [], this._hints);
        return new Logger(this._loggerSink, this._name, this._hints, scopeName, record);
    }
    endScope(status) {
        if (this._scopeName)
            this._loggerSink.log(this._name, 'info', `<= ${this._scopeName} ${status}`, [], this._hints);
    }
    _innerLog(severity, message, ...args) {
        if (this._recording)
            this._recording.push(`[${this._name}] ${message}`);
        this._loggerSink.log(this._name, severity, message, args, this._hints);
    }
    recording() {
        return this._recording ? this._recording.slice() : [];
    }
}
exports.Logger = Logger;
class Loggers {
    constructor(userSink) {
        const loggerSink = new MultiplexingLoggerSink();
        if (userSink)
            loggerSink.add('user', userSink);
        if (helper_1.helper.isDebugMode())
            loggerSink.add('pwdebug', new PwDebugLoggerSink());
        loggerSink.add('debug', new DebugLoggerSink());
        this.api = new Logger(loggerSink, 'api', { color: 'cyan' });
        this.browser = new Logger(loggerSink, 'browser', {});
        this.protocol = new Logger(loggerSink, 'protocol', { color: 'green' });
    }
}
exports.Loggers = Loggers;
class MultiplexingLoggerSink {
    constructor() {
        this._loggers = new Map();
    }
    add(id, logger) {
        this._loggers.set(id, logger);
    }
    get(id) {
        return this._loggers.get(id);
    }
    remove(id) {
        this._loggers.delete(id);
    }
    isEnabled(name, severity) {
        for (const logger of this._loggers.values()) {
            if (logger.isEnabled(name, severity))
                return true;
        }
        return false;
    }
    log(name, severity, message, args, hints) {
        for (const logger of this._loggers.values()) {
            if (logger.isEnabled(name, severity))
                logger.log(name, severity, message, args, hints);
        }
    }
}
const colorMap = new Map([
    ['red', 160],
    ['green', 34],
    ['yellow', 172],
    ['blue', 33],
    ['magenta', 207],
    ['cyan', 45],
    ['reset', 0],
]);
class DebugLoggerSink {
    constructor() {
        this._debuggers = new Map();
        if (process.env.DEBUG_FILE) {
            const ansiRegex = new RegExp([
                '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
                '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
            ].join('|'), 'g');
            const stream = fs.createWriteStream(process.env.DEBUG_FILE);
            debug.log = (data) => {
                stream.write(data.replace(ansiRegex, ''));
                stream.write('\n');
            };
        }
    }
    isEnabled(name, severity) {
        return debug.enabled(`pw:${name}`);
    }
    log(name, severity, message, args, hints) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
            cachedDebugger = debug(`pw:${name}`);
            this._debuggers.set(name, cachedDebugger);
            let color = hints.color || 'reset';
            switch (severity) {
                case 'error':
                    color = 'red';
                    break;
                case 'warning':
                    color = 'yellow';
                    break;
            }
            const escaped = colorMap.get(color) || 0;
            if (escaped)
                cachedDebugger.color = String(escaped);
        }
        cachedDebugger(message, ...args);
    }
}
exports.DebugLoggerSink = DebugLoggerSink;
class PwDebugLoggerSink {
    isEnabled(name, severity) {
        return false;
    }
    log(name, severity, message, args, hints) {
    }
}
//# sourceMappingURL=logger.js.map